-- Use of this source code is governed by the Apache 2.0 license; see COPYING.

module(...,package.seeall)

-- Poptrie, see
--   http://conferences.sigcomm.org/sigcomm/2015/pdf/papers/p57.pdf
--
-- [Algorithm 1] lookup(t = (N , L), key); the lookup procedure for the address
-- key in the tree t (when k = 6). The function extract(key, off, len) extracts
-- bits of length len, starting with the offset off, from the address key.
-- N and L represent arrays of internal nodes and leaves, respectively.
-- << denotes the shift instruction of bits. Numerical literals with the UL and
-- ULL suffixes denote 32-bit and 64-bit unsigned integers, respectively.
-- Vector and base are the variables to hold the contents of the node’s fields.
--
-- if [direct pointing] then
--    index = extract(key, 0, t.s);
--    dindex = t.D[index].direct index;
--    if (dindex & (1UL << 31)) then
--       return dindex & ((1UL << 31) - 1);
--    end if
--    index = dindex;
--    offset = t.s;
-- else
--    index = 0;
--    offset = 0;
-- end if
-- vector = t.N [index].vector;
-- v = extract(key, offset, 6);
-- while (vector & (1ULL << v)) do
--    base = t.N [index].base1;
--    bc = popcnt(vector & ((2ULL << v) - 1));
--    index = base + bc - 1;
--    vector = t.N [index].vector;
--    offset += 6;
--    v = extract(key, offset, 6);
-- end while
-- base = t.N [index].base0;
-- if [leaf compression] then
--    bc = popcnt(t.N [index].leafvec & ((2ULL << v) - 1));
-- else
--    bc = popcnt((∼t.N [index].vector) & ((2ULL << v) - 1));
-- end if
-- return t.L[base + bc - 1];

local ffi = require("ffi")
local bit = require("bit")
local band, lshift, rshift = bit.band, bit.lshift, bit.rshift

local Poptrie = {
   k = 6,
   node_t = ffi.typeof([[struct {
      uint64_t leafvec, vector;
      uint32_t base0, base1;
   }]]),
   leaf_t = ffi.typeof("uint16_t")
}

function new (init)
   local num_default = 4
   local pt = {
      nodes = (init and init.nodes)
         or ffi.new("$[?]", node_t, num_default),
      num_nodes = (init and init.nodes and assert(init.num_nodes))
         or num_default,
      leaves = (init and init.leaves)
         or ffi.new("$[?]", leaf_t, num_default),
      num_leaves = (init and init.leaves and assert(init.num_leaves))
         or num_default
   }
   return setmetatable(pt, {__index=Poptrie})
end

function Poptrie:grow_nodes ()
   self.num_nodes = self.num_nodes * 2
   local new_nodes = ffi.new("$[?]", node_t, self.num_nodes)
   ffi.copy(new_nodes, self.nodes, ffi.sizeof(self.nodes))
   self.nodes = new_nodes
end

function Poptrie:grow_leaves ()
   self.num_leaves = self.num_leaves * 2
   local new_leaves = ffi.new("$[?]", leaf_t, self.num_leaves)
   ffi.copy(new_leaves, self.leaves, ffi.sizeof(self.leaves))
   self.leaves = new_leaves
end

local function extract (key, offset, length)
   return band(rshift(key, offset), lshift(1, length) - 1)
end

-- http://graphics.stanford.edu/~seander/bithacks.html#IntegerLogObvious
local function msb (i)
   local r = 0
   while i ~= 0 do
      r = r + 1
      i = rshift(i, 1)
   end
   return r
end

-- RIB (sorted by key, ascending):
--  { { key=uint8_t[?], length=uint8_t value=uint16_t }, ...}
function Poptrie:build (rib, node_base, leaf_base, offset)
   -- When called with only rib, create the root node.
   node_base = node_base or 0
   leaf_base = leaf_base or 0
   offset = offset or 0
   -- Allocate this node, grow nodes array if necessary.
   while not node_base < self.num_nodes do
      self:grow_nodes()
   end
   local node = self.nodes[node_base]
   -- Initialize node base pointers.
   node_base = node_base + 1
   node.base0 = node_base
   node.base1 = leaf_base
   -- Compute the number of direct child nodes.
   local num_children = 0
   for child = 0, 2^Poptrie.k - 1 do
      for _, entry in ipairs(rib) do
         if extract(entry.key, offset, Poptrie.k) == child
         and entry.length > offset + Poptrie.k then
            num_children = num_children + 1
            break
         end
      end
   end
   -- Increment node_base for first direct child node.
   node_base = node_base + num_children
   -- Build direct child nodes.
      for child = 0, 2^Poptrie.k - 1 do
   
   
   for offset = 0, 1/0, Poptrie.k do
      local continue
      for _, entry in ipairs(rib) do
         local prefix, leaf_value = unpack(entry)
         local length = msb(prefix)
         if length > offset - Poptrie.k then
            continue = true
            if length > offset then
               -- node
               
            else
               -- leaf
            end
         end
      end
      if not continue then
         return
      end
   end
end



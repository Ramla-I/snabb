#!snabb snsh

-- Use of this source code is governed by the GNU AGPL license; see COPYING.

local shm = require("core.shm")
local lib = require("core.lib")
local worker = require("core.worker")
local counter = require("core.counter")
local vita = require("program.vita.vita")
local gentest = require("program.vita.gentest")
local basic_apps = require("apps.basic.basic_apps")
local Synth = require("apps.test.synth").Synth
local PcapFilter = require("apps.packet_filter.pcap_filter").PcapFilter
local ethernet= require("lib.protocol.ethernet")
local ipv4 = require("lib.protocol.ipv4")
local datagram = require("lib.protocol.datagram")
local CPUSet = require("lib.cpuset")
local yang = require("lib.yang.yang")
local S = require("syscall")

-- Synopsis:
--
--    sudo program/vita/test.snabb \
--       [<pktsize>|IMIX] [<npackets>] [<nroutes>] [<cpu>]
--
--     Default is 10 million packets at IMIX via one route. Optionally, accepts
--     a comma-separated list of CPU ids to bind processes to.              (-:
--
-- This is a software-only benchmark scenario for Vita. It simulates a single
-- Vita node with the public ports being connected in loop-back mode (i.e.,
-- routes lead to itself). Synthetic traffic is injected into the private input
-- port, and throughput is measured at a filter connected to the private output
-- port. ARP requests on the private output port are routed back into the
-- private input port.
--
-- Here is a diagram of the app graph implemented in this test case:
--
--                          +-----------+
--                   output |           |
--            +-------------+   Synth   |
--            |             |           |
--            |             +-----------+
--      +-----v----+
--      |          |
--      |   Join   +-----+
--      |          |     |
--      +-----+----+     |           +--------------+
--            ^          |           |              |
--            |          +----------->              +---------+
--        arp |              private |     Vita     | public  |
--            |          +-----------+              <---------+
--      +-----+-----+    |           |              |
--      |           |    |           +--------------+
--      |   Filter  <----+
--      |           |  ^
--      +-----------+  :....(throughput measured here)
--
-- While this benchmark should be suitable to evaluate relative performance
-- differences between Vita versions, it is not representative of real-world
-- performance since it does not involve NIC drivers present in an actual L2
-- network.
--
-- For a more realistic test case use gentest.snabb in conjunction with snabb
-- loadtest.

local conf, sim_packets = gentest.gen_testcase({
      private_interface = {
         nexthop_ip4 = gentest.private_interface_defaults.ip4.default
      },
      packet_size = tonumber(main.parameters[1]) or main.parameters[1],
      nroutes = tonumber(main.parameters[3])
})

local cpuset = CPUSet.new()
local cpuspec = main.parameters[4]
if cpuspec then
   cpuset:add_from_string(cpuspec)
end

local dest_link_name
local function configure_private_router_softbench (conf)
   local c, private = vita.configure_private_router(conf)

   config.app(c, "bridge", basic_apps.Join)
   config.link(c, "bridge.output -> "..private.input)

   config.app(c, "synth", Synth, {packets=sim_packets})
   config.link(c, "synth.output -> bridge.synth")

   config.app(c, "sieve", PcapFilter, {filter="arp"})
   dest_link_name = config.canonical_link(private.output.." -> sieve.input")
   config.link(c, dest_link_name)
   config.link(c, "sieve.output -> bridge.arp")

   return c
end

local function configure_public_router_loopback (conf)
   local c, public = vita.configure_public_router(conf)
   config.link(c, public.output.." -> "..public.input)
   return c
end

local function vita_softbench_workers (conf)
   return {
      key_manager = vita.configure_exchange(conf),
      outbound_router = configure_private_router_softbench(conf),
      inbound_router = configure_public_router_loopback(conf),
      encapsulate = vita.configure_esp(conf),
      decapsulate =  vita.configure_dsp(conf)
   }
end

local function find_stats_counters ()
   local workers = worker.status()
   if workers.outbound_router then
      local pid = children.outbound_router.pid
      local function dest_link_stats (name)
         return ("/%d/links/%s/%s.counter"):format(pid, dest_link_name, name)
      end
      if  shm.exists(dest_link_stats('txpackets'))
      and shm.exists(dest_link_stats('txbytes')) then
         return {
            txpackets = shm.open(dest_link_stats('txpackets'), 'readonly'),
            txbytes = shm.open(dest_link_stats('txbytes'), 'readonly')
         }
      end
   end
end

-- adapted from snabbnfv traffic

local npackets = tonumber(main.parameters[2]) or 10e6
local get_monotonic_time = require("ffi").C.get_monotonic_time
local start, packets, bytes = 0, 0, 0
local stats
local function measure ()
   stats = stats or find_stats_counters()
   local txpackets = counter.read(stats.txpackets)
   local txbytes = counter.read(stats.txbytes)
   if start == 0 and txpackets > 100 then
      -- started receiving, record time and packet count
      packets = txpackets
      bytes = txbytes
      start = get_monotonic_time()
   end
   if txpackets - packets >= npackets then
      -- test complete, report results and exit
      local runtime = get_monotonic_time() - start
      local packets = tonumber(counter.read(stats.txpackets) - packets)
      local bytes = tonumber(counter.read(stats.txbytes) - bytes)
      print(("Processed %.1f million packets in %.2f seconds (%d bytes; %.2f Gbps)")
            :format(packets / 1e6, runtime, bytes, bytes * 8.0 / 1e9 / runtime))
      print(("Rate(Mpps):\t%.3f"):format(packets / runtime / 1e6))
      main.exit()
   end
end

worker.set_exit_on_worker_death(true)
timer.activate(timer.new('measure', measure, 1e9/10, 'repeating')) -- 10 Hz
vita.run_vita(vita_softbench_workers, conf, cpuset)
